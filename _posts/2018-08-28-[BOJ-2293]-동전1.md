---
layout: post
title: "[BOJ 2293] 동전1"
slug: "boj_2293"
date: 2018-08-28 19:38:00 +0900
categories: blog/algorithm
---

# [BOJ 2293] 동전1

예제를 통해 알아보자. 10원을 만들기 위해서는  9원 + 1원, 8원 + 1원, 5원 + 5원의 3가지 부분문제로 나뉜다. 따라서 다음과 같은 점화식을 생각해낸다. 


$$
D[K] = \sum_{1\leq i \leq n}(D[K-coin[i]])
$$


하지만 위 점화식은 단순히 마지막에 어떻게 더할 것인지로 계산하기 때문에 중복되는 경우가 포함된다. 예를 들어,  $$D[3] = D[2]+D[1]$$ 에서 $$\{D[2], 1\} = \{1,1,1\},\{2,1\}$$  이고, $$\{D[1], 2\} = \{1,2\}$$ 이다. $$\{2,1\}$$ 이나 $$\{1,2\}$$ 는 같은 경우이나 위 점화식에서는 다른 경우로 생각한다. 따라서, 다른 방법이 필요하다.



위의 예제에서 $$\{1,2\} $$ 나 $$\{2,1\}$$ 의 경우는 같다. 순서는 중요하지 않고, 조합이 어떻게 되느냐의 문제기 때문에, 사용된 각 동전의 갯수가 같을 때 같은 결과라고 할 수 있다.  동전을 몇개까지 사용하는지를 위 점화식에 추가를 해보자. $$D[i][j]$$ 는 $$i$$ 번째 동전까지 사용해서 $$j$$ 원을 만드는 경우의 수이다. 이렇게 되면 $$\{1, 2\}$$ 나 $$\{2, 1\}$$ 은 둘 다 2번째 동전까지 사용하여 $$3$$ 을 만드는 되는 같은 경우가 된다. 다음과 같은 점화식을 세울 수 있다.
$$
D[i][j] = D[i][j-coin[i]] + D[i-1][j]
$$


$$i$$ 번째 동전까지 사용해서 $$j$$ 원을 만드는 경우는 $$i$$ 번째 동전까지 사용해서 $$j -coin[i]$$ 원을 만드는 경우와 $$i$$ 번째 동전을 사용하지 않고 $$j$$ 원을 만드는 경우로 나눌 수 있다. 



## 최적화

위의 점화식에서 $$D[i][j]$$ 는 이전 행 $$D[i-1][j]$$ 의 값을 더하면서 구해진다. 새로운 $$i$$ 번째 행을 추가하여 $$D[i][j]$$ 를 구하는 대신, 이전에 구했던 값에 그대로 덮어씌운다면 메모리를 줄일 수 있을 것이다. 이는 바로 직전에 구했던 값만이 다음 식에 필요하기 때문에 할 수 있다. 따라서 점화식은 다음과 같이 더 간단히 줄일 수 있다.
$$
D[j] = D[j-coin[i]] + D[j]
$$


```c++
#include <iostream>
using namespace std;

int coin[101];
int dp[10001];

int main() {
	int n, k;
	cin >> n >> k;

	for (int i = 1; i <= n; i++) {
		cin >> coin[i];
	}

	dp[0] = 1;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= k; j++) {
			if (j - coin[i] >= 0)
				dp[j] += dp[j - coin[i]];
			
		}
	}
	cout << dp[k] << endl;
}
```

