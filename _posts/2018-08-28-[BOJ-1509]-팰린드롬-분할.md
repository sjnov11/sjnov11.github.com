---
layout: post
title: "[BOJ 1509] 팰린드롬 분할"
slug: "boj_1509"
date: 2018-08-28 15:42:00 +0900
categories: blog/algorithm
---

# [BOJ 1509] 팰린드롬 분할

문제를 어떻게 작은 문제로 나누는지 생각하기 어려운 문제였다. 



길이 $$ N$$ 의 문자열이 있다. 이 문자열의 팰린드롬 분할의 최소값은 어떻게 구할 수 있을까?

$$N$$ 번째 문자로 인해 **항상 새로운 팰린드롬**이 만들어진다(길이가 1인 팰린드롬에서 부터 $$N$$ 인 팰린드롬까지). 이 때, $$N$$ 번째 문자로 만들어지는 팰린드롬은 여러가지 경우가 있다. 예를 들어, 문자열 $$AABA$$ 에서 $$A$$ 가 추가되는 경우를 보자. 새롭게 만들어지는 팰린드롬은 $$\{A, AA, AABAA\}$$ 의 3가지 경우가 존재한다. 

새로운 팰린드롬이 만들어진다면, 만들어진 팰린드롬을 제외한 부분의 부분문제가 남게 된다. 다시말해, ***$$N$$ 번째 문자로 만들어지는 팰린드롬 +남은 부분 문자열에서 팰린드롬 분할의 최솟값의 문제***  가 된다. 위에서 들었던 예제에서는 각각 $$\{AABA, AAB, NIL\}$$ 문자열에서 팰린드롬 분할의 최솟값을 구하는 문제가 된다.

정리하면 다음과 같은 과정으로 문제의 답을 구할 수 있다.

1) $$N$$ 번째 문자가 추가되면서 만들어지는 팰린드롬의 모든 경우에 대해서
2) $$N-j$$  번째 문자가 추가되면서 만들어지는 팰린드롬 분할의 최솟값 중 가장 작은 값의 + 1 이 $$dp[N]$$ 의 값이다. ($$j$$ 는 팰린드롬 시작 $$index- 1$$)



여기서 모든 팰린드롬의 경우를 구하려면 어떻게 해야할까? 

$$(1,N), (2,N), (3,N), ... , (N-1, N), (N,N)$$ 부분 문자열에 대해서 모두 팰린드롬 여부를 확인해 주어야 한다. 우리는 앞서 부분 팰린드롬 확인을 다이나믹 프로그래밍으로 구하였다.



## 시간 복잡도

각 부분 문자열에 대한 팰린드롬 여부 확인은 부분문제의 갯수가 $$N^2/2$$ 개이고, 한 문제를 푸는데 $$O(1)$$ 의 시간이 걸린다. 따라서, 팰린드롬 확인 문제를 모두 푸는데 $$O(N^2)$$ 의 시간이 걸린다.

다음으로, 팰린드롬 분할 최소값을 구할 때, $$1$$ 번째 문자에서 부터 $$N$$ 번째 문자가 추가될 때 까지 문제를 풀게 되므로 문제의 갯수 $$N$$개, 각 문제 마다 팰린드롬 확인을 $$N$$ 번 하므로 $$O(N^2)$$ 의 시간복잡도를 갖는다.

따라서 $$O(N^2) + O(N^2) = O(N^2)$$  이다.



```c++
#include <iostream>
#include <string>
using namespace std;

int dp[2501];
int pal[2501][2501];
string S;

int isPal(int s, int e) {
	if (pal[s][e] >= 0) return pal[s][e];
	if (s == e) return pal[s][e] = 1;
	if (s > e) return 1;
	if (S[s - 1] != S[e - 1]) return pal[s][e] = 0;
	return pal[s][e] = isPal(s + 1, e - 1);
}


int main() {
	cin >> S;
	
	
	for (int i = 1; i <= S.size(); i++) {
		dp[i] = 99999999;
	}
	for (int i = 1; i <= S.size(); i++) {
		for (int j = 1; j <= S.size(); j++) {
			pal[i][j] = -1;
		}
	}
	
	dp[0] = 0;
	dp[1] = 1;
	for (int i = 2; i <= S.size(); i++) {		
		for (int j = 1; j < i; j++) {
			if (isPal(j, i)) {
				if (dp[i] > dp[j - 1] + 1) {
					dp[i] = dp[j - 1] + 1;
				}
			}
		}
		if (dp[i] > dp[i - 1] + 1) {
			dp[i] = dp[i - 1] + 1;
		}
	}
	cout << dp[S.size()] << "\n";
}
```

